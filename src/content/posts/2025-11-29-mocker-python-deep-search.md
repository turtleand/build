---
title: "Deep Search: How does mocker in Python work?"
description: "References, comparisons, and implementation notes gathered during the Deep Search for pytest-mock's mocker fixture."
date: 2025-11-23
tags: ["python", "mocks", "deep-search"]
featured: false
draft: false
locale: en
translationKey: python-mocker
isDeepSearch: true
slug: "2025-11-29-mocker-python-deep-search"
---

# Understanding pytest-mock's mocker Fixture: Implementation and Best Practices

## Key Resources and Insights

* **Official pytest-mock Documentation** – The official docs explain that pytest-mock provides a **mocker fixture** as a thin wrapper around the standard unittest.mock patching API[\[1\]](https://pytest-mock.readthedocs.io/en/latest/#:~:text=This%20pytest%20plugin%20provides%20a,provided%20by%20the%20mock%20package). It automatically undoes patches after each test, provides convenient helpers like spy() and stub(), and leverages pytest’s introspective assertions for mock call comparisons[\[2\]](https://pytest-mock.readthedocs.io/en/latest/#:~:text=Besides%20undoing%20the%20mocking%20automatically,pytest%20introspection%20when%20comparing%20calls).

* **pytest-mock Implementation (Source Level)** – Under the hood, the plugin defines mocker as a pytest fixture. It creates a MockerFixture object and **yields** it to tests, then calls stopall() to **unpatch everything on teardown[\[3\]](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from#:~:text=%40pytest.fixture%28%29%20def%20mocker%28pytestconfig%3A%20Any%29%20,stopall)**. Pytest’s fixture injection by name means you don’t import mocker; instead, pytest supplies it when it sees a test function argument named “mocker”[\[4\]](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from#:~:text=The%20,when%20it%20runs%20the%20test).

* **Ned Batchelder’s “Why your mock doesn’t work”** – A widely cited blog post illustrating *where to patch*. It demonstrates that you must patch the **attribute where it’s *used***, not where it’s defined. For example, if product.py does from os import listdir, patching "os.listdir" won’t affect product.py – you need to patch "product.listdir" (the name in the product module)[\[5\]](https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html#:~:text=The%20only%20difference%20here%20from,real%20name%20than%20the%20other). By **mocking where the object is used**, your test precisely targets the intended dependency and avoids confusion[\[6\]](https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html#:~:text=By%20mocking%20where%20the%20object,py).

* **Pytest-with-Eric “Common Mocking Problems”** – An in-depth guide highlighting best practices and pitfalls. It reiterates to **always patch the exact location of use, not the definition**[\[7\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=Note%20%E2%80%94%20Always%20patch%20the,where%20it%20was%20originally%20defined). It also shows how using autospec=True can prevent mistakes – by enforcing the real function’s signature on your mocks, autospeccing will catch calls with wrong arguments that a bare Mock would silently allow[\[8\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=How%20). This resource also warns against globally patching modules like requests in tests (which can leak into other tests) and instead advises patching within your module/class under test for isolation[\[9\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=Patching%20standard%20modules%20like%20,globally%20can%20be%20dangerous)[\[10\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=directly,of%20the%20best%20practices%20below).

* **Comparing mocker vs. monkeypatch** – Several blog posts (e.g. by **Neuralception** and a Mergify article) compare pytest’s two patching mechanisms. They note that **monkeypatch** (built-in fixture) is great for simple attribute or environment tweaks (e.g. set an env var or replace a function with a dummy)[\[11\]](https://articles.mergify.com/pytest-mock-2/#:~:text=Monkeypatch%3A%20Surgical%20Precision%20for%20Attributes,and%20Environments). However, **mocker** (from *pytest-mock*) provides a broader range of features for complex scenarios – it creates real Mock/MagicMock objects, allows detailed call assertions, and handles multiple patches more cleanly[\[12\]](https://articles.mergify.com/pytest-mock-2/#:~:text=broader%20range%20of%20features%20than,your%20code%20and%20its%20dependencies). One author observes that using mocker.patch “streamlines” replacing a function (you can just supply a return value or side effect) and comes with call-tracking out of the box, whereas with monkeypatch you’d manually craft a stub function or value[\[13\]](https://www.neuralception.com/python-better-unittest-pytest/#:~:text=Given%20that%20using%20,way%20to%20do%20it%20here). In practice, monkeypatch shines for quick, surgical modifications, while mocker is preferred for cases requiring **MagicMock abilities (automated stubs, spies, call count assertions, etc.)[\[14\]](https://articles.mergify.com/pytest-mock-2/#:~:text=match%20at%20L297%20This%20table,features%20needed%20for%20complex%20scenarios)**.

* **DataCamp’s pytest-mock Tutorial** – A beginner-friendly tutorial (Dec 2024\) covering both fundamentals and advanced usage. It reiterates that pytest-mock **builds on Python’s built-in unittest.mock module** to simplify testing[\[15\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=pytest,process%20of%20mocking%20during%20testing). The tutorial provides examples of using mocker to speed up tests (e.g. patching time.sleep to skip delays[\[16\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_long_running_task%28mocker%29%3A%20,Task%20Complete)), patch object properties (using mocker.patch.object with PropertyMock for @property attributes[\[17\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_user_is_adult%28mocker%29%3A%20,is_adult%20is%20True)), simulate sequences of calls with side\_effect, and use **spies** to verify interactions without altering behavior[\[18\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_log_message_with_spy%28mocker%29%3A%20,Test%20message). It also emphasizes not to overuse mocks – over-mocking can make tests brittle, so mock only what’s truly necessary[\[19\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=Best%20Practices%20for%20Using%20pytest).

## How the mocker Fixture Works (Integration with Pytest)

The mocker fixture is provided by the **pytest-mock plugin** and is seamlessly integrated into pytest’s fixture system. You **do not import** mocker; instead, declare it as a parameter in your test function, and pytest will inject the fixture object for you[\[4\]](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from#:~:text=The%20,when%20it%20runs%20the%20test). Internally, pytest-mock registers mocker via @pytest.fixture. For each test, it instantiates a MockerFixture (which wraps the standard unittest.mock library) and yields it to your test code[\[3\]](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from#:~:text=%40pytest.fixture%28%29%20def%20mocker%28pytestconfig%3A%20Any%29%20,stopall). After the test finishes, the fixture’s teardown logic automatically calls mocker.stopall(), ensuring that **all patches are undone** so they don’t leak into other tests[\[3\]](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from#:~:text=%40pytest.fixture%28%29%20def%20mocker%28pytestconfig%3A%20Any%29%20,stopall). This design means you can call mocker.patch(...) multiple times in a test, and you won’t need any manual cleanup – the fixture handles the lifecycle of all mocks.

**What does MockerFixture provide?** In essence, the mocker fixture gives you an interface that mirrors the unittest.mock API. According to the docs, the fixture’s API is intentionally the **same as mock.patch** and supports the same arguments[\[20\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=The%20,patch%2C%20supporting%20the%20same%20arguments). You can do things like:

mocker.patch('package.module.Func', return\_value=42)  
mocker.patch.object(SomeClass, 'method', autospec=True)  
fake\_obj \= mocker.Mock(spec=AnotherClass)

Each call to mocker.patch() uses the underlying unittest.mock.patch under the hood, but with the benefit that pytest-mock will track the patch and undo it at the end of the test. In fact, mocker.patch, mocker.patch.object, mocker.patch.dict, etc., are all available and behave just like the standard library versions[\[21\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=def%20test_foo%28mocker%29%3A%20,isfile)[\[22\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=The%20supported%20methods%20are%3A). The fixture also exposes core mock classes and constants directly, so you can use mocker.Mock, mocker.MagicMock, mocker.PropertyMock, mocker.ANY, and so on, without additional imports[\[23\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=Also%2C%20as%20a%20convenience%2C%20these,mocker). This convenience makes it easy to create standalone mock objects (for example, mocker.Mock() to create a new mock you can configure as needed).

**Automatic teardown:** A key advantage is that you no longer need to use patchers as context managers or decorators. In unittest-style tests, one might use with patch(...): or the @patch(...) decorator. Pytest-mock eliminates this need – you call mocker.patch() imperatively in the test, and it’s automatically reverted after. In fact, using mocker.patch as a context manager is *not* supported and will raise a warning[\[24\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=Although%20mocker%E2%80%99s%20API%20is%20intentionally,not%20supported%20through%20the%20fixture) (because the fixture intends to handle setup/teardown for you). The plugin authors encourage a **declarative style** within tests instead of nested context managers[\[25\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=It%20may%20lead%20to%20an,the%20flow%20of%20the%20test)[\[26\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=,functions). If you really need to use a context manager (e.g. to patch something only in a with block), pytest-mock provides mocker.patch.context\_manager to avoid the warning[\[24\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=Although%20mocker%E2%80%99s%20API%20is%20intentionally,not%20supported%20through%20the%20fixture) – but generally, you can structure tests without that.

## Features of mocker: Patch, Spy, Stub, and More

Beyond basic patching, mocker offers some high-level utilities:

* **Patching Functions/Methods:** You can patch functions or methods by name with mocker.patch("module.name", ...) or use mocker.patch.object. These support all the same arguments as unittest.mock.patch – e.g. autospec=True to restrict the mock to the spec of the target object, or side\_effect to define custom behaviors. For example, to avoid slow tests you might do: mocker.patch("time.sleep", return\_value=None) so that a function that calls time.sleep(5) doesn’t actually wait[\[16\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_long_running_task%28mocker%29%3A%20,Task%20Complete). You can patch properties or attributes as well; for instance, patching a property requires using patch.object with a new\_callable=PropertyMock (pytest-mock makes PropertyMock available via mocker.PropertyMock)[\[17\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_user_is_adult%28mocker%29%3A%20,is_adult%20is%20True).

* **Spies:** The mocker.spy(obj, "method") creates a spy on a real function or method. A spy wraps the original such that calls go through to the real implementation, but call information is recorded. The returned spy object is actually a MagicMock, so you can use assertions like spy.assert\_called\_with(...) or check spy.call\_count[\[18\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_log_message_with_spy%28mocker%29%3A%20,Test%20message). In addition, spies have extra attributes like spy.spy\_return (the last return value of the function) and spy.call\_count or spy\_return\_list (list of all return values if called multiple times)[\[27\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=The%20object%20returned%20by%20,in%20the%20examples%20above)[\[28\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=,3.13). Use spy when you want to **verify that a real function was called with certain arguments or returned something**, without stubbing it out. For example, you might spy on a logger’s info method to assert it was called, while still actually logging the message[\[18\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_log_message_with_spy%28mocker%29%3A%20,Test%20message). (Under the hood, spying is achieved by wrapping the target in a MagicMock that delegates to the original function.)

* **Stubs:** mocker.stub() creates a simple **“dummy”** function – essentially a Mock that can accept any arguments. This is useful for injecting into code that expects a callback or function, when you don’t need any real implementation. The stub will do nothing (return None unless configured otherwise), but you can still verify it was called with expected arguments via stub.assert\_called\_once\_with(...), etc.[\[29\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=Stub%C2%B6)[\[30\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=stub%20%3D%20mocker). In short, use a stub when you just need a placeholder function that records calls (for example, if your code allows passing in a callback, you can pass a stub and later assert it was called appropriately).

* **Managing Mocks:** Pytest-mock adds a couple of helpers to manage multiple mocks. mocker.resetall() will call reset\_mock() on *all* mocks created via the fixture so far[\[31\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=) – this can be handy if you want to reset call counts or call history mid-test (though needing this is relatively rare). There’s also mocker.stopall(), which stops all active patches at once (effectively undoing all patches). As noted, stopall() is automatically invoked at the end of each test, but you could call it manually if you needed to undo everything partway through a test’s execution (perhaps to restore original behavior for some subsequent assertions)[\[2\]](https://pytest-mock.readthedocs.io/en/latest/#:~:text=Besides%20undoing%20the%20mocking%20automatically,pytest%20introspection%20when%20comparing%20calls). Additionally, as of pytest-mock 3.10+, you can stop specific patches or spies by calling mocker.stop(patch\_obj) on the object returned from mocker.patch or mocker.spy[\[32\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=As%20of%20version%203,can%20be%20also%20selectively%20stopped)[\[33\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=mocker,call_count%20%3D%3D%201). This gives fine-grained control if you want to un-do a particular patch before test end.

* **Fixture Scoping Options:** By default, mocker is a function-scoped fixture (each test function gets a fresh instance and patches don’t persist beyond it). The plugin also provides fixtures like class\_mocker, module\_mocker, package\_mocker, session\_mocker for broader scope patching[\[34\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=It%20is%20also%20possible%20to,scopes%20using%20the%20appropriate%20fixture). These can be useful if you want to apply a patch once for a whole test class or module. For example, using module\_mocker in a module-scoped fixture would allow a patch to remain for all tests in that module (and be undone after the module). Caution is needed with wider scopes to avoid unintended interaction between tests – but it’s available for optimization or special cases.

## mocker.patch vs unittest.mock.patch vs pytest.monkeypatch

**Comparing mocker.patch and unittest.mock.patch:** The behavior of mocker.patch is essentially identical to unittest.mock.patch in terms of outcome – both will replace the target with a Mock/MagicMock and allow you to set return values or assert calls. The key difference is *how* you use them in tests. With pure unittest.mock, you often use the patch() function as a decorator or context manager. For example, to patch os.remove, you might write:

@patch("os.remove")  
def test\_something(mock\_remove): ...

or use with patch("os.remove") as mock\_remove: inside the test. These approaches work, but start to get unwieldy when you need multiple patches. The pytest-mock mocker fixture instead encourages an in-test, imperative style: you simply call mocker.patch("os.remove") inside the test. This has several benefits noted by the plugin’s author:

* You don’t have to clutter the test function’s signature with a bunch of extra mock arguments that you might not even use. (With multiple @patch decorators, the test function receives parameters for each mock, and their order depends on the decorator order[\[35\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=,functions).) Using mocker, your test function just requests one fixture and you call patch as needed within the body.

* It composes cleanly with other pytest features. For instance, receiving mocks as function arguments can conflict with pytest fixtures or parametrized tests (name collisions or ordering issues)[\[36\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=). The mocker fixture avoids that, since you only get the one fixture and manage multiple patches from it internally. This aligns nicely with pytest’s design of fixtures as named dependencies.

* It’s easy to apply or remove patches mid-test. With the decorator approach, patches last the entire test function. With context managers, you get nested indentation and need an ExitStack for more than one at a time. In contrast, you can call mocker.patch() several times in a row at the top of your test (no extra indent) to set up all necessary fakes. And if needed, you could even mocker.stop(specific\_patch) to undo one during the test. The plugin documentation points out that undoing a patch during execution is cumbersome with the standard library approach[\[37\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=,pytest.mark.parametrize), but pytest-mock makes it feasible (though it’s not commonly needed). In summary, mocker.patch offers a more **flexible and pytest-friendly syntax** for doing everything you would with unittest.mock.patch – the core mocking mechanics are the same, but the usage pattern is improved for readability and maintainability.

**Comparing mocker and monkeypatch:** Pytest’s built-in monkeypatch fixture is another way to alter behavior in tests, and it often comes up alongside mocker. Both serve to isolate the system under test from real dependencies, but they have different strengths. The **monkeypatch fixture allows low-level modifications**: you can set an attribute on a module or object (monkeypatch.setattr), replace an item in a dictionary (monkeypatch.setitem), or set environment variables (monkeypatch.setenv), etc. It’s very straightforward – you give it a target and a new value. This is ideal for situations like *temporarily changing a global or constant*, adjusting an environment variable, or injecting a simple stub. For example, you might do monkeypatch.setenv('API\_URL', 'testing-url') or monkeypatch.setattr(SomeClass, 'CLASS\_CONSTANT', 123\) in a test to override configuration. Common use cases include exactly those kinds of tweaks[\[11\]](https://articles.mergify.com/pytest-mock-2/#:~:text=Monkeypatch%3A%20Surgical%20Precision%20for%20Attributes,and%20Environments).

On the other hand, **mocker provides a higher-level mocking interface** built on unittest.mock. When you call mocker.patch, it *creates a MagicMock for you*, sets it in place of the target, and gives you that mock object to configure or assert on. This means with mocker you can easily do things like: specify a return value or side effect for a function, check how many times it was called, or even use autospec to ensure the fake matches the real function’s signature. The monkeypatch fixture by itself doesn’t create Mock objects – you have to provide the replacement. Sometimes that replacement is easy (e.g. a constant or a simple lambda), but other times you’d essentially be manually creating a mock anyway. The mocker fixture shines in those cases because it streamlines the creation of the mock and provides **rich assertion methods**. As one comparison put it, mocker supports a “broader range of features” than monkeypatch, allowing complex mock objects and detailed verification of interactions[\[12\]](https://articles.mergify.com/pytest-mock-2/#:~:text=broader%20range%20of%20features%20than,your%20code%20and%20its%20dependencies). This makes mocker the go-to choice for testing *intricate interactions*, such as ensuring a function was called with certain arguments, or simulating a sequence of calls.

To illustrate, consider you want to test a function that makes an HTTP request. Using monkeypatch, you might do:

def fake\_request(url):  
    return FakeResponseObject(...)  \# some dummy response  
monkeypatch.setattr(requests, "get", fake\_request)

This works, but you had to craft fake\_request and a FakeResponseObject. With mocker, you could instead do:

mock\_resp \= mocker.Mock(spec=requests.Response)  
mock\_resp.json.return\_value \= {"key": "value"}  
mocker.patch("requests.get", return\_value=mock\_resp)

This requires less custom code (the Mock can simulate the response), and you can now also do requests.get.assert\_called\_once\_with(...) to verify it was called correctly, thanks to the auto-created mock. In short, **use monkeypatch for simple attribute overrides or environmental setups, and use mocker when you need the power of Mock objects and call assertions**. According to one source, *monkeypatch “shines in its simplicity” for direct modifications, while mocker provides the robust features needed for complex scenarios*[\[14\]](https://articles.mergify.com/pytest-mock-2/#:~:text=match%20at%20L297%20This%20table,features%20needed%20for%20complex%20scenarios).

It’s worth noting that these tools aren’t mutually exclusive – you can even combine them in a single test. For example, you might use monkeypatch to set an environment variable and use mocker to spy on a function call in the same test. In fact, a guide suggests that sometimes using both together can be the “most powerful approach” for comprehensive testing[\[38\]](https://articles.mergify.com/pytest-mock-2/#:~:text=match%20at%20L301%20Sometimes%2C%20combining,Understanding). The key is to choose the right tool for each job: **if all you need is to swap out a value or function quickly, monkeypatch is often simpler; if you need a mock with introspection, use mocker**. One author’s personal guideline was that they favor mocker for replacing functions because it’s more streamlined (no need to write a dummy function as with monkeypatch) and provides call tracking, whereas monkeypatch is perfectly fine for straightforward state changes[\[39\]](https://www.neuralception.com/python-better-unittest-pytest/#:~:text=Given%20that%20using%20,way%20to%20do%20it%20here). Ultimately both achieve isolation; mocker just builds in more test verification capabilities.

## Best Practices and Common Pitfalls in Mocking (with pytest-mock)

**1\. Patch where the dependency is used, not where it’s defined:** This is a fundamental rule when using mocks (regardless of pytest-mock or not). If your code under test imports something like from module import Foo, then inside that code, Foo is a **local name** – patching the original module’s class won’t affect the local name. Always patch the name *that the code actually references*. As the documentation and Ned Batchelder’s article emphasize, you should patch in the context of the consuming module[\[5\]](https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html#:~:text=The%20only%20difference%20here%20from,real%20name%20than%20the%20other). A concise way to remember this: *imported names are like copies*. If X imported Y as Z, then Z lives in X’s namespace – that’s what you must patch. Failing to do so is a common reason “my mock didn’t work.” When in doubt, refer to the official docs or Ned’s blog for the explanation of Python’s import assignment semantics and why the correct patch target is critical[\[6\]](https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html#:~:text=By%20mocking%20where%20the%20object,py)[\[7\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=Note%20%E2%80%94%20Always%20patch%20the,where%20it%20was%20originally%20defined).

**2\. Use autospec=True to catch usage errors:** Whenever feasible, enable autospeccing on your patches (or use mocker.patch.object(..., autospec=True)). This option tells the mock to “mirror” the interface of the real object. It will prevent you from calling methods or attributes that don’t exist on the real thing. Without autospec, a Mock will let you call any attribute name (it will just create a new mock for that name), which can mask bugs. For example, if you mistype a method name on a mock, the test will still pass, but your production code would fail. By using autospec or creating your mocks via mocker.create\_autospec (analogous to unittest.mock.create\_autospec), you add a safety net – calling a non-existent method on the mock will raise an attribute error. A referenced best-practice is *“mocks should always have a spec”*, meaning developers should default to autospec to avoid false confidence in tests[\[8\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=How%20). In short, **autospec makes your mocks behave more like the real objects** and thus makes tests more robust.

**3\. Don’t over-mock – prefer real objects or simpler fakes when reasonable:** Mocks are powerful but can lead to fragile tests if overused. The pytest-mock tutorial cautions against *over-mocking*, noting that tests can become brittle and too tightly coupled to implementation details[\[19\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=Best%20Practices%20for%20Using%20pytest). If you find yourself mocking a lot of things, consider if a different testing strategy would be better (for instance, using a temporary file instead of mocking file I/O, or using a lightweight fake object instead of mocking out a whole class). Over-mocking can also obscure what the code is actually doing, making tests harder to understand. Aim to mock only external interactions or truly slow/hard-to-control dependencies – not the code under test’s core logic. In particular, avoid “mocking data”: for example, instead of mocking a database call *and* the data it returns, it might be better to use a test database or a fake repository object. Mocks are best used for *behavior verification* (did X get called? was Y invoked with these args?) and for isolating side effects (stop the code from really sending an email or calling an API). If you use them to essentially rewrite all of your code’s behavior in the test, then the test isn’t validating much.

**4\. Prefer mocker/patch for complex behaviors, and use monkeypatch for simple state changes:** As discussed, each has its place. A common pitfall is using monkeypatch to replace a function when you actually need to make assertions about how that function was called – monkeypatch won’t give you call\_count or assert\_called\_with easily. In that scenario, you’re better off using mocker.patch so you can leverage the mock’s call history. Conversely, if you just need to, say, make a constant return a different value or tweak an environment variable for a test, monkeypatch is quick and clear. Using mocker in that case might be overkill (e.g., mocker.patch('module.CONSTANT', new=42) is fine, but monkeypatch.setattr(module, 'CONSTANT', 42\) is equally clear and doesn’t require the plugin). **Choose the tool that leads to simpler test code.** Both will clean up automatically (monkeypatch reverts changes after each test as well), so the main consideration is clarity and needed features.

**5\. Take advantage of pytest’s fixture design for organizing patches:** If you have many tests that all require the same patch, you can factor that into a fixture. Pytest-mock’s mocker can be used inside fixture functions too. For example, you might have:

@pytest.fixture  
def patched\_db(mocker):  
    mocker.patch("myapp.database.connect", return\_value=FakeConnection())  
    return mocker

Then tests that need the DB patched can just accept patched\_db (which itself is basically the mocker fixture pre-configured). This is better than copy-pasting the same mocker.patch("myapp.database.connect", ...) in multiple tests. Alternatively, as shown in one article, you can write your own fixture using unittest.mock.patch in a with block and yield – but since we have mocker, it's often simpler to use it directly in a fixture as shown, or use the provided module\_mocker etc., for module-scoped patches. The key is to adhere to DRY principles: if a patch is needed in many places, define it in one fixture and reuse that.

**6\. Be mindful of patching scope and leakage:** Although pytest-mock cleans up patches at the end of each test function (when using the default function-scope mocker), issues can arise if you change the scope. If you use module\_mocker or session\_mocker, remember that those patches persist longer. Ensure that’s really what you want, and be cautious that one test’s patches don’t inadvertently affect another test. If you encounter strange behavior (e.g., a mock from a previous test seems to still be in effect), it could be due to patch scope. In the rare case of encountering leakage with normal mocker, calling mocker.stopall() at the start of a test (or end of the previous one) can force-clean patches[\[40\]](https://github.com/pytest-dev/pytest-mock/issues/84#:~:text=,stopall), but normally this isn’t necessary. Proper use of the fixture should avoid leaks.

**7\. Avoid mixing patching strategies in confusing ways:** It’s perfectly valid to use mocker and monkeypatch together, or pytest-mock and vanilla unittest.mock together, but make sure it’s clear which tool is doing what. For example, if you use a @patch decorator on a test and also use mocker inside that test, you need to understand their order (decorator patches apply before the test function is called, whereas mocker calls happen during the test). This can be managed, but generally stick to one style within a single test for clarity. Pytest-mock’s fixture is usually the more convenient route in pytest. If you’re transitioning from unittest-style tests, it might be tempting to keep using @patch decorators in some places – you can, but consider converting them to use mocker for consistency.

**8\. Read error output and utilize pytest introspection:** When a mock assertion fails (e.g., assert\_called\_once\_with fails), pytest-mock works with pytest to show you an introspective diff of call arguments. This can be extremely helpful in figuring out what calls were actually made. Make sure to leverage that output. If you see \<MagicMock name='something' ...\> not called., it means your code never invoked the function – this might hint that your patch target was incorrect or the code path changed. If a call count assertion fails, the pytest output will list the actual calls recorded, making it easier to diagnose. This is an advantage of using mocker/unittest.mock over simpler monkeypatch stubs, because you get that rich output for free.

By adhering to these best practices, you can make the most of pytest-mock’s mocker fixture while avoiding common pitfalls. The combination of pytest’s fixture system with the powerful mocking capabilities of the unittest.mock library can significantly streamline testing of code with external dependencies. Just remember: use mocks judiciously, keep tests focused, and ensure your patches truly simulate the real interactions in a meaningful way. With mocker, you have a convenient tool to do this – now backed by an understanding of how it’s implemented and how to use it effectively.

---

[\[1\]](https://pytest-mock.readthedocs.io/en/latest/#:~:text=This%20pytest%20plugin%20provides%20a,provided%20by%20the%20mock%20package) [\[2\]](https://pytest-mock.readthedocs.io/en/latest/#:~:text=Besides%20undoing%20the%20mocking%20automatically,pytest%20introspection%20when%20comparing%20calls) pytest-mock documentation

[https://pytest-mock.readthedocs.io/en/latest/](https://pytest-mock.readthedocs.io/en/latest/)

[\[3\]](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from#:~:text=%40pytest.fixture%28%29%20def%20mocker%28pytestconfig%3A%20Any%29%20,stopall) [\[4\]](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from#:~:text=The%20,when%20it%20runs%20the%20test) python \- Where does \`pytest\`'s \`mocker\` come from? \- Stack Overflow

[https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from](https://stackoverflow.com/questions/71169948/where-does-pytests-mocker-come-from)

[\[5\]](https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html#:~:text=The%20only%20difference%20here%20from,real%20name%20than%20the%20other) [\[6\]](https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html#:~:text=By%20mocking%20where%20the%20object,py) Why your mock doesn’t work | Ned Batchelder

[https://nedbatchelder.com/blog/201908/why\_your\_mock\_doesnt\_work.html](https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html)

[\[7\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=Note%20%E2%80%94%20Always%20patch%20the,where%20it%20was%20originally%20defined) [\[8\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=How%20) [\[9\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=Patching%20standard%20modules%20like%20,globally%20can%20be%20dangerous) [\[10\]](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#:~:text=directly,of%20the%20best%20practices%20below) Common Mocking Problems & How To Avoid Them (+ Best Practices) | Pytest with Eric

[https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/](https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/)

[\[11\]](https://articles.mergify.com/pytest-mock-2/#:~:text=Monkeypatch%3A%20Surgical%20Precision%20for%20Attributes,and%20Environments) [\[12\]](https://articles.mergify.com/pytest-mock-2/#:~:text=broader%20range%20of%20features%20than,your%20code%20and%20its%20dependencies) [\[14\]](https://articles.mergify.com/pytest-mock-2/#:~:text=match%20at%20L297%20This%20table,features%20needed%20for%20complex%20scenarios) [\[38\]](https://articles.mergify.com/pytest-mock-2/#:~:text=match%20at%20L301%20Sometimes%2C%20combining,Understanding) Master pytest mock: Tips to Improve Your Python Tests

[https://articles.mergify.com/pytest-mock-2/](https://articles.mergify.com/pytest-mock-2/)

[\[13\]](https://www.neuralception.com/python-better-unittest-pytest/#:~:text=Given%20that%20using%20,way%20to%20do%20it%20here) [\[39\]](https://www.neuralception.com/python-better-unittest-pytest/#:~:text=Given%20that%20using%20,way%20to%20do%20it%20here) Better unit tests with pytest-mock and monkeypatch \-

[https://www.neuralception.com/python-better-unittest-pytest/](https://www.neuralception.com/python-better-unittest-pytest/)

[\[15\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=pytest,process%20of%20mocking%20during%20testing) [\[16\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_long_running_task%28mocker%29%3A%20,Task%20Complete) [\[17\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_user_is_adult%28mocker%29%3A%20,is_adult%20is%20True) [\[18\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=def%20test_log_message_with_spy%28mocker%29%3A%20,Test%20message) [\[19\]](https://www.datacamp.com/tutorial/pytest-mock#:~:text=Best%20Practices%20for%20Using%20pytest) pytest-mock Tutorial: A Beginner’s Guide to Mocking in Python | DataCamp

[https://www.datacamp.com/tutorial/pytest-mock](https://www.datacamp.com/tutorial/pytest-mock)

[\[20\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=The%20,patch%2C%20supporting%20the%20same%20arguments) [\[21\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=def%20test_foo%28mocker%29%3A%20,isfile) [\[22\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=The%20supported%20methods%20are%3A) [\[23\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=Also%2C%20as%20a%20convenience%2C%20these,mocker) [\[24\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=Although%20mocker%E2%80%99s%20API%20is%20intentionally,not%20supported%20through%20the%20fixture) [\[27\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=The%20object%20returned%20by%20,in%20the%20examples%20above) [\[28\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=,3.13) [\[29\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=Stub%C2%B6) [\[30\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=stub%20%3D%20mocker) [\[31\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=) [\[32\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=As%20of%20version%203,can%20be%20also%20selectively%20stopped) [\[33\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=mocker,call_count%20%3D%3D%201) [\[34\]](https://pytest-mock.readthedocs.io/en/latest/usage.html#:~:text=It%20is%20also%20possible%20to,scopes%20using%20the%20appropriate%20fixture) Usage \- pytest-mock documentation

[https://pytest-mock.readthedocs.io/en/latest/usage.html](https://pytest-mock.readthedocs.io/en/latest/usage.html)

[\[25\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=It%20may%20lead%20to%20an,the%20flow%20of%20the%20test) [\[26\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=,functions) [\[35\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=,functions) [\[36\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=) [\[37\]](https://pytest-mock.readthedocs.io/en/latest/remarks.html#:~:text=,pytest.mark.parametrize) Remarks \- pytest-mock documentation

[https://pytest-mock.readthedocs.io/en/latest/remarks.html](https://pytest-mock.readthedocs.io/en/latest/remarks.html)

[\[40\]](https://github.com/pytest-dev/pytest-mock/issues/84#:~:text=,stopall) Python3 \+ pytest \+ pytest-mock: Mocks leaking into other test functions breaking assertions? · Issue \#84 · pytest-dev/pytest-mock · GitHub

[https://github.com/pytest-dev/pytest-mock/issues/84](https://github.com/pytest-dev/pytest-mock/issues/84)
